# Ralph loop (https://github.com/snarktank/ralph) — each agent runs in a fresh
# session with clean context. Memory persists via git history and progress files.
id: feature-dev
name: Feature Development Workflow
version: 6
description: |
  Story-based execution pipeline. Planner decomposes tasks into user stories.
  Setup prepares the environment and establishes baseline.
  Developer implements each story (with tests) in a fresh session. Verifier checks each story.
  Then integration/E2E testing, PR creation, and code review.
  v6: Added design standards, backend standards, and quality gates.

cron:
  interval_ms: 120000  # 2 minutes instead of 5

polling:
  model: minimax/MiniMax-M2.5
  timeoutSeconds: 120

agents:
  - id: planner
    name: Planner
    role: analysis
    description: Decomposes tasks into ordered user stories.
    workspace:
      baseDir: agents/planner
      files:
        AGENTS.md: agents/planner/AGENTS.md
        SOUL.md: agents/planner/SOUL.md
        IDENTITY.md: agents/planner/IDENTITY.md

  - id: setup
    name: Setup
    role: coding
    description: Prepares environment, creates branch, establishes baseline.
    workspace:
      baseDir: agents/setup
      files:
        AGENTS.md: ../../agents/shared/setup/AGENTS.md
        SOUL.md: ../../agents/shared/setup/SOUL.md
        IDENTITY.md: ../../agents/shared/setup/IDENTITY.md

  - id: developer
    name: Developer
    role: coding
    description: Implements features, writes tests, creates PRs.
    workspace:
      baseDir: agents/developer
      files:
        AGENTS.md: agents/developer/AGENTS.md
        SOUL.md: agents/developer/SOUL.md
        IDENTITY.md: agents/developer/IDENTITY.md

  - id: verifier
    name: Verifier
    role: verification
    description: Quick sanity check - did developer actually do the work?
    workspace:
      baseDir: agents/verifier
      skills:
        - agent-browser
      files:
        AGENTS.md: ../../agents/shared/verifier/AGENTS.md
        SOUL.md: ../../agents/shared/verifier/SOUL.md
        IDENTITY.md: ../../agents/shared/verifier/IDENTITY.md

  - id: tester
    name: Tester
    role: testing
    description: Integration and E2E testing after all stories are implemented.
    workspace:
      baseDir: agents/tester
      files:
        AGENTS.md: agents/tester/AGENTS.md
        SOUL.md: agents/tester/SOUL.md
        IDENTITY.md: agents/tester/IDENTITY.md

  - id: reviewer
    name: Reviewer
    role: analysis
    description: Reviews PRs, requests changes or approves.
    workspace:
      baseDir: agents/reviewer
      skills:
        - agent-browser
      files:
        AGENTS.md: agents/reviewer/AGENTS.md
        SOUL.md: agents/reviewer/SOUL.md
        IDENTITY.md: agents/reviewer/IDENTITY.md

steps:
  - id: plan
    agent: planner
    input: |
      Decompose the following task into ordered user stories for autonomous execution.

      TASK:
      {{task}}

      Instructions:
      1. Explore the codebase to understand the stack, conventions, and patterns
      2. Read references/design-standards.md for available palettes and font pairs
      3. Read references/brainstorming-protocol.md for architectural decision-making
      4. Break the task into small user stories (max 20)
      5. Order by dependency: design tokens first, then schema/DB, backend, frontend, integration
      6. Each story must fit in one developer session (one context window)
      7. Every acceptance criterion must be mechanically verifiable
      8. Always include "Typecheck passes" as the last criterion in every story
      9. Every story MUST include test criteria — "Tests for [feature] pass"
      10. The developer is expected to write tests as part of each story

      DESIGN SYSTEM — Select a cohesive design direction for the project:
      - Read references/design-standards.md for available palettes and font pairs
      - Choose: aesthetic direction (minimal, brutalist, luxury, editorial, industrial, organic, playful, corporate)
      - Choose: color palette matching the project's domain (from the 8 palettes in the reference)
      - Choose: font pair (heading + body) from the 10-pair reference table
      - Choose: icon library (Lucide React or Heroicons)
      - NEVER choose: Inter, Roboto, Arial, system-ui fonts
      - NEVER choose: purple gradient as primary aesthetic
      - NEVER plan for emoji icons
      - Include design tokens (CSS custom properties) in the FIRST user story
      - Output: DESIGN_SYSTEM block with chosen values

      Reply with:
      STATUS: done
      REPO: /path/to/repo
      BRANCH: feature-branch-name
      DESIGN_SYSTEM:
        aesthetic: [direction]
        palette: [name]
        heading_font: [font]
        body_font: [font]
        icon_library: [library]
      STORIES_JSON: [ ... array of story objects ... ]
    expects: "STATUS: done"
    max_retries: 2
    on_fail:
      escalate_to: human

  - id: setup
    agent: setup
    input: |
      Prepare the development environment for this feature.

      TASK:
      {{task}}

      REPO: {{repo}}
      BRANCH: {{branch}}

      Instructions:
      1. If the repo directory does not exist: mkdir -p {{repo}} && cd {{repo}} && git init
         If it exists: cd into the repo
      2. CRITICAL - Ensure GitHub remote exists:
         - Run: git remote -v
         - If NO remote named 'origin' exists, create the GitHub repo:
           PROJECT_NAME=$(basename {{repo}})
           gh repo create hikmetgulsesli/$PROJECT_NAME --public --source . --remote origin --push 2>/dev/null || true
         - If remote exists but repo doesn't exist on GitHub:
           gh repo create hikmetgulsesli/$PROJECT_NAME --public --source . --remote origin --push 2>/dev/null || true
         - Verify: git remote -v (must show origin)
      3. Create the feature branch (git checkout -b {{branch}})
      4. Read package.json, CI config, test config to understand the build/test setup
      5. Run the build to establish a baseline
      6. Run the tests to establish a baseline
      7. Create a references/ symlink in the repo root:
         ln -sfn /home/setrox/.openclaw/antfarm-repo/references references
      8. Report what you found

      Reply with:
      STATUS: done
      BUILD_CMD: <build command>
      TEST_CMD: <test command>
      CI_NOTES: <brief CI notes>
      BASELINE: <baseline status>
    expects: "STATUS: done"
    max_retries: 2
    on_fail:
      escalate_to: human

  - id: implement
    agent: developer
    type: loop
    loop:
      over: stories
      completion: all_done
      fresh_session: true
      verify_each: true
      verify_step: verify
    input: |
      Implement the following user story. You are working on ONE story in a fresh session.

      TASK (overall):
      {{task}}

      REPO: {{repo}}
      BRANCH: {{branch}}
      BUILD_CMD: {{build_cmd}}
      TEST_CMD: {{test_cmd}}

      CURRENT STORY:
      {{current_story}}

      COMPLETED STORIES:
      {{completed_stories}}

      STORIES REMAINING: {{stories_remaining}}

      VERIFY FEEDBACK (if retrying):
      {{verify_feedback}}

      PROGRESS LOG:
      {{progress}}

      BEFORE writing any code:
      1. Read references/design-standards.md — follow ALL rules
      2. Read references/backend-standards.md — follow ALL rules
      3. Read references/web-guidelines.md — check accessibility + performance
      4. NEVER use: emoji icons, Inter/Roboto/Arial fonts, purple gradients, transition:all
      5. ALWAYS use: SVG icons from chosen library, project font pair, project color palette
      6. ALWAYS use: cursor-pointer on clickable elements, hover states, focus-visible rings
      7. ALWAYS use: parameterized queries, typed errors, proper HTTP status codes

      Instructions:
      1. Read progress-{{run_id}}.txt — especially the Codebase Patterns section
      2. Pull latest on the branch
      3. Implement this story only, following ALL design and backend standards
      4. Write tests for this story's functionality
      5. Run typecheck / build
      6. Run tests to confirm they pass
      7. Commit: feat: {{current_story_id}} - {{current_story_title}}
      8. Append to progress-{{run_id}}.txt
      9. Update Codebase Patterns if you found reusable patterns

      Reply with:
      STATUS: done
      CHANGES: what you implemented
      TESTS: what tests you wrote
    expects: "STATUS: done"
    max_retries: 2
    on_fail:
      escalate_to: human

  - id: verify
    agent: verifier
    input: |
      Verify the developer's work on this story.

      TASK (overall):
      {{task}}

      REPO: {{repo}}
      BRANCH: {{branch}}
      CHANGES: {{changes}}
      TEST_CMD: {{test_cmd}}

      CURRENT STORY:
      {{current_story}}

      PROGRESS LOG:
      {{progress}}

      Check:
      1. Code exists (not just TODOs or placeholders)
      2. Each acceptance criterion for the story is met
      3. Tests were written for this story's functionality
      4. Tests pass (run {{test_cmd}})
      5. No obvious incomplete work
      6. Typecheck passes

      ## Design Quality Verification (Frontend Changes)
      Has frontend changes: {{has_frontend_changes}}

      If {{has_frontend_changes}} is 'true', you MUST also check design quality:
      1. Read references/design-checklist.md
      2. Check EVERY item on the visual quality checklist
      3. REJECT if: emoji icons found anywhere in the UI
      4. REJECT if: Inter, Roboto, Arial, or system-ui used as primary font
      5. REJECT if: cursor-pointer missing on clickable elements
      6. REJECT if: no hover/focus states on interactive elements
      7. REJECT if: contrast ratio below 4.5:1
      8. REJECT if: transition:all used anywhere
      9. Use the agent-browser skill to visually inspect the changed UI
      10. Open the changed HTML file directly (file:// URL) or spin up a local dev server
      11. Take a screenshot of the rendered page
      12. Visually confirm layout renders correctly, styling applied, elements present
      13. Include your visual and design quality findings in VERIFIED output

      If {{has_frontend_changes}} is 'false', skip visual verification entirely.

      ## Backend Quality Verification
      If backend changes exist, also check:
      1. No SQL string concatenation (parameterized queries only)
      2. .env is in .gitignore
      3. No secrets hardcoded in source code
      4. Proper error handling (no empty catch blocks)

      Reply with:
      STATUS: done
      VERIFIED: What you confirmed

      Or if incomplete:
      STATUS: retry
      ISSUES:
      - What's missing or incomplete
    expects: "STATUS: done"
    on_fail:
      retry_step: implement
      max_retries: 2
      on_exhausted:
        escalate_to: human

  - id: test
    agent: tester
    input: |
      Integration and E2E testing of the implementation.

      TASK:
      {{task}}

      REPO: {{repo}}
      BRANCH: {{branch}}
      CHANGES: {{changes}}
      BUILD_CMD: {{build_cmd}}
      TEST_CMD: {{test_cmd}}

      PROGRESS LOG:
      {{progress}}

      BEFORE testing, read:
      1. references/web-guidelines.md — accessibility and performance standards
      2. references/debugging-protocol.md — systematic debugging if tests fail

      Your job (integration/E2E testing — unit tests were already written per-story):
      1. Run the full test suite ({{test_cmd}}) to confirm everything passes together
      2. Look for integration issues between stories
      3. If this is a UI feature, use agent-browser to test it end-to-end
      4. Check cross-cutting concerns: error handling, edge cases across features
      5. Verify the overall feature works as a cohesive whole
      6. If frontend: check accessibility (semantic HTML, keyboard nav, aria attributes)
      7. If frontend: check performance (lazy loading, font preload, image dimensions)

      If tests fail, follow the debugging protocol: reproduce, trace, hypothesize, fix ONE thing at a time.

      Reply with:
      STATUS: done
      RESULTS: What you tested and the outcomes

      Or if issues found:
      STATUS: retry
      FAILURES:
      - Specific test failures or bugs found
    expects: "STATUS: done"
    on_fail:
      retry_step: implement
      max_retries: 2
      on_exhausted:
        escalate_to: human

  - id: pr
    agent: developer
    input: |
      Create a pull request for your changes.

      TASK:
      {{task}}

      REPO: {{repo}}
      BRANCH: {{branch}}
      CHANGES: {{changes}}
      RESULTS: {{results}}

      PROGRESS LOG:
      {{progress}}

      Create a PR with:
      - Clear title summarizing the change
      - Description explaining what and why
      - Reference to what was tested

      Use: gh pr create

      Reply with:
      STATUS: done
      PR: URL to the pull request
    expects: "STATUS: done"
    on_fail:
      escalate_to: human

  - id: review
    agent: reviewer
    input: |
      Review the pull request.

      PR: {{pr}}
      TASK: {{task}}
      CHANGES: {{changes}}

      PROGRESS LOG:
      {{progress}}

      BEFORE reviewing, read:
      1. references/design-standards.md — design rules and anti-patterns
      2. references/design-checklist.md — visual QA checklist
      3. references/backend-standards.md — backend quality standards

      Review for:
      - Code quality and clarity
      - Potential bugs or issues
      - Test coverage
      - Follows project conventions

      DESIGN QUALITY GATE:
      REJECT the PR if ANY of these are true:
      - Uses emoji characters as UI icons
      - Uses Inter, Roboto, Arial, or system-ui as primary font
      - Uses purple-gradient-on-white or purple-gradient-on-dark color scheme
      - Has no hover/focus states on interactive elements
      - Missing cursor-pointer on clickable elements
      - Has no responsive breakpoints
      - Layout is a basic centered single-column with no visual character
      - Uses transition:all anywhere
      When rejecting for design quality, cite the specific rule from design-standards.md.

      BACKEND QUALITY GATE:
      REJECT the PR if ANY of these are true:
      - SQL string concatenation detected (injection risk)
      - .env file committed or not in .gitignore
      - Secrets hardcoded in source code
      - Empty catch blocks (silent error swallowing)
      - Generic error responses (everything returns 500)

      Use: gh pr view, gh pr diff to read the PR.

      IMPORTANT: Post your review to the PR on GitHub using:
      - If approving: gh pr review <number> --approve --body "your review summary"
      - If requesting changes: gh pr review <number> --request-changes --body "your feedback"

      ## Visual Review (Frontend Changes)
      Has frontend changes: {{has_frontend_changes}}

      If {{has_frontend_changes}} is 'true', you MUST also perform a visual design review:
      1. Check out the branch: git checkout {{branch}}
      2. Use the agent-browser skill to open the changed page (file:// URL or local dev server)
      3. Take a screenshot of the rendered page
      4. Run through references/design-checklist.md — every CRITICAL item must pass
      5. Evaluate visual polish and design quality:
         - Does the UI look polished and intentional, not rough or AI-generated?
         - Are colors, typography, and spacing consistent with the design system?
         - Is the layout visually balanced with appropriate asymmetry?
         - Do interactive elements have visible hover/focus/active states?
         - Is the overall design distinctive — not generic dark Tailwind template?
      6. Include your visual design assessment in the review output

      If {{has_frontend_changes}} is 'false', skip visual review entirely.

      If changes needed, add comments to the PR explaining what needs to change.

      Reply with:
      STATUS: done
      DECISION: approved

      Or if changes needed:
      STATUS: retry
      DECISION: changes_requested
      FEEDBACK:
      - What needs to change
    expects: "STATUS: done"
    on_fail:
      retry_step: implement
      max_retries: 3
      on_exhausted:
        escalate_to: human

  - id: external-review
    agent: reviewer
    input: |
      Read and address external code review comments on the PR from automated reviewers (GitHub Copilot, Gemini Code Review, etc.)

      PR: {{pr}}
      TASK: {{task}}
      REPO: {{repo}}
      BRANCH: {{branch}}
      BUILD_CMD: {{build_cmd}}
      TEST_CMD: {{test_cmd}}

      PROGRESS LOG:
      {{progress}}

      Instructions:
      1. Wait 90 seconds for automated review bots to finish:
         sleep 300

      2. Check if all PR checks have completed:
         gh pr checks {{pr}} || true

      3. Read ALL review comments on the PR:
         gh api repos/{owner}/{repo}/pulls/{number}/reviews
         gh api repos/{owner}/{repo}/pulls/{number}/comments
         gh pr view {{pr}} --comments

      4. Collect all actionable feedback from:
         - GitHub Copilot review comments
         - Gemini Code Review comments
         - Any other automated reviewer comments
         - Ignore "LGTM" / approval-only reviews with no code changes requested

      5. If there are actionable code issues (bugs, security, performance, style violations):
         - cd into {{repo}}, checkout {{branch}}, pull latest
         - Fix each issue mentioned in the comments
         - Run {{build_cmd}} to verify the build still passes
         - Run {{test_cmd}} to verify tests still pass (if test command exists)
         - Commit: fix: address external review feedback
         - Push: git push
         - Reply with STATUS: done and list what you fixed

      6. If there are NO actionable issues (only approvals, or no bot comments):
         - Reply with STATUS: done and note that no fixes were needed

      7. After fixing, re-read comments one more time to confirm nothing was missed.

      Reply with:
      STATUS: done
      FIXES: list of what was fixed (or "none needed")
      EXTERNAL_REVIEWS: summary of bot feedback received

      Or if you cannot fix an issue:
      STATUS: retry
      ISSUES:
      - What could not be fixed and why
    expects: "STATUS: done"
    on_fail:
      retry_step: implement
      max_retries: 2
      on_exhausted:
        escalate_to: human

  - id: merge
    agent: developer
    input: |
      Merge the pull request and clean up.

      PR: {{pr}}
      REPO: {{repo}}
      BRANCH: {{branch}}

      PROGRESS LOG:
      {{progress}}

      Instructions:
      1. Verify PR is in a mergeable state:
         gh pr view {{pr}} --json mergeable,mergeStateStatus

      2. If mergeable, squash-merge the PR:
         gh pr merge {{pr}} --squash --delete-branch

      3. If NOT mergeable (conflicts, failing checks):
         - Report the issue and do NOT force merge
         - Reply with STATUS: retry

      4. After merge, verify:
         gh pr view {{pr}} --json state

      Reply with:
      STATUS: done
      MERGED: true
      MERGE_SHA: <commit sha from merge>

      Or if merge failed:
      STATUS: retry
      ISSUES:
      - Why merge failed
    expects: "STATUS: done"
    on_fail:
      escalate_to: human
